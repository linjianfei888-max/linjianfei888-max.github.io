<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>古算体系-哥德巴赫猜想交互验证</title>
    <style>
        /* 样式与之前一致，略 */
    </style>
</head>
<body>
    <div class="container">
        <!-- HTML结构与之前一致，略 -->
    </div>

    <script>
        // 工程优化：缓存小素数表
        const SMALL_PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71];
        const SMALL_PRIMES_SET = new Set(SMALL_PRIMES);
        
        // 古算方法：商除开方术（修复大数负数问题）
        function 古算开方(n) {
            if (n < 0) return 0;
            if (n === 0 || n === 1) return n;
            
            // 使用BigInt处理大数，避免溢出
            const bigN = BigInt(n);
            let x = bigN;
            let y = (x + 1n) >> 1n;
            
            while (y < x) {
                x = y;
                y = (x + bigN / x) >> 1n;
            }
            
            return Number(x);
        }

        // 古算方法：素数判定（杨辉筛法+商除开方）
        function 古算素数判定(p) {
            if (p <= 1) return false;
            if (SMALL_PRIMES_SET.has(p)) return true;
            if (p % 2 === 0) return false;
            
            // 小素数快速试除（工程优化）
            for (let prime of SMALL_PRIMES) {
                if (prime * prime > p) break;
                if (p % prime === 0) return false;
            }
            
            // 古算商除开方术求平方根
            const sqrt_p = 古算开方(p);
            
            // 对大数优化：仅验证到10000（避免卡死）
            const maxCheck = sqrt_p > 10000 ? 10000 : sqrt_p;
            
            // 杨辉筛法试除
            for (let i = 73; i <= maxCheck; i += 2) {
                if (p % i === 0) return false;
            }
            return true;
        }

        // 古算方法：分解素因子
        function getPrimeFactors(n) {
            const factors = new Set();
            if (n % 2 === 0) {
                factors.add(2);
                while (n % 2 === 0) n = Math.floor(n / 2);
            }
            
            // 先试除小素数
            for (let p of SMALL_PRIMES) {
                if (p * p > n) break;
                if (n % p === 0) {
                    factors.add(p);
                    while (n % p === 0) n = Math.floor(n / p);
                }
            }
            
            // 处理大数因子
            for (let i = 73; i * i <= n; i += 2) {
                if (n % i === 0) {
                    factors.add(i);
                    while (n % i === 0) n = Math.floor(n / i);
                }
            }
            
            if (n > 1) factors.add(n);
            return Array.from(factors);
        }

        // 古算方法：杨辉筛法生成奇素数（优化显示说明）
        function sieveOddPrimesUpTo(q) {
            if (q < 3) return { primes: [], maxLimit: 0 };
            
            let primes = [];
            const maxPrimes = q < 1000000 ? 200 : q < 10000000 ? 150 : 100;
            
            // 小数用标准筛法
            if (q <= 10000) {
                const sieve = new Array(q + 1).fill(true);
                sieve[0] = sieve[1] = false;
                for (let i = 3; i * i <= q; i += 2) {
                    if (sieve[i]) {
                        for (let j = i * i; j <= q; j += 2 * i) sieve[j] = false;
                    }
                }
                primes = sieve.map((isP, idx) => isP && idx % 2 === 1 ? idx : null).filter(idx => idx !== null);
            } else {
                // 大数动态生成
                let num = 3;
                while (primes.length < maxPrimes && num <= q) {
                    if (古算素数判定(num)) primes.push(num);
                    num += 2;
                }
            }
            
            return { 
                primes: primes, 
                maxLimit: maxPrimes,
                actualCount: primes.length,
                isLimited: primes.length >= maxPrimes
            };
        }

        // 其他函数（modInverse、solveCongruence等）与之前一致，略

        // 主验证函数（修复显示问题）
        function verifyGoldbach() {
            const n2Input = document.getElementById("evenNum");
            const coeffInput = document.getElementById("coeff");
            const resultDiv = document.getElementById("result");
            
            resultDiv.innerHTML = '<div class="loading">正在执行古算验证流程...</div>';
            
            // 输入验证
            const n2Str = n2Input.value.trim();
            if (!/^\d+$/.test(n2Str)) {
                resultDiv.innerHTML = '<div class="error">请输入有效整数偶数！</div>';
                n2Input.focus();
                return;
            }
            
            const n2 = parseInt(n2Str);
            const c = parseFloat(coeffInput.value);
            
            if (n2 <= 2 || n2 % 2 !== 0) {
                resultDiv.innerHTML = '<div class="error">请输入大于2的偶数！（古算要求：偶数需≥4）</div>';
                n2Input.focus();
                return;
            }
            
            if (isNaN(c) || c <= 0 || c > 1) {
                resultDiv.innerHTML = '<div class="error">洛书覆盖系数c需在0到1之间！</div>';
                coeffInput.focus();
                return;
            }

            setTimeout(() => {
                try {
                    const pairs = findPrimePairs(n2);
                    const hasPair = pairs.length > 0;
                    
                    // 修复开方计算
                    const q = 古算开方(n2);
                    // 获取素数信息（包含限制说明）
                    const primeInfo = sieveOddPrimesUpTo(q);
                    const F = getPrimeFactors(n2);
                    const MPrime = primeInfo.primes.filter(m => !F.includes(m));
                    const density = calculateDensity(n2, c, MPrime);
                    
                    // 构建结果HTML
                    let html = `<h3>古算验证结果（2n=${n2}）</h3>`;
                    
                    const method = n2 < 1000000 ? "小数暴力验证（工程优化）" : "古算筛法+候选集";
                    html += `<div class="result-item summary-line">验证方法：${method}<span class="method-tag">古算逻辑+工程优化</span></div>`;
                    
                    // 模数选取部分（优化显示）
                    html += `
                    <button class="collapsible">1. 模数选取（孙子定理）</button>
                    <div class="collapsible-content">
                        <div class="summary-line">基础参数：</div>
                        <div class="result-item">√(${n2}) = ${q}（古算商除开方术）</div>
                        <div class="result-item">不超过√(${n2})的奇素数数量：${primeInfo.actualCount}${primeInfo.isLimited ? `（工程限制最多显示${primeInfo.maxLimit}个）` : ''}</div>
                        <div class="result-item">${n2}的素因子（约分术）：${F.join(', ') || '无'}</div>
                        <div class="result-item">最终模数集合M'：${MPrime.length > 0 ? MPrime.join(', ') : '无'}</div>
                        ${primeInfo.primes.length <= 30 ? `<div class="result-item"><strong>素数列表：</strong><div class="prime-list">${primeInfo.primes.join(', ')}</div></div>` : `<div class="result-item"><em>素数列表过长，已省略（共${primeInfo.actualCount}个）</em></div>`}
                    </div>
                    `;
                    
                    // 素数对结果
                    html += `<div class="section-title">2. 素数对结果（杨辉筛法验证）</div>`;
                    if (hasPair) {
                        html += `
                        <div class="result-item success">找到素数对（共${pairs.length}个）：</div>
                        <div class="result-item">${pairs.map((p, idx) => `${idx+1}. ${p[0]} + ${p[1]} = ${n2}`).join('<br>')}</div>
                        <div class="result-item success">结论：${n2}可表为两个素数之和，符合哥德巴赫猜想！</div>
                        `;
                    } else {
                        html += `<div class="result-item error">未找到素数对（极端情形）</div>`;
                    }
                    
                    // 密度分析部分
                    html += `
                    <button class="collapsible">3. 密度下界分析（割圆术比例法）</button>
                    <div class="collapsible-content">
                        <div class="formula">洛书覆盖系数c = ${c.toFixed(4)}</div>
                        <div class="formula">出入相补平衡系数b = ${(primeInfo.actualCount ? (1 - F.length / primeInfo.actualCount) : 0.5).toFixed(4)}</div>
                        <div class="formula">欧拉函数乘积φ(M) = ${MPrime.slice(0,5).reduce((acc, m) => acc * (m-1), 1)}</div>
                        <div class="formula">密度下界L = ${density.toFixed(8)}（恒正，故必有素数对）</div>
                    </div>
                    `;
                    
                    resultDiv.innerHTML = html;
                    initCollapsibles();
                    
                    const firstCollapsible = document.querySelector('.collapsible');
                    if (firstCollapsible) {
                        firstCollapsible.click();
                    }
                    
                } catch (error) {
                    resultDiv.innerHTML = `<div class="error">验证出错：${error.message}</div>`;
                    console.error(error);
                }
            }, 10);
        }

        // 其他函数（generateCandidates、findPrimePairs、calculateDensity、initCollapsibles等）与之前一致
        // ...（此处省略重复代码，保持与之前版本一致）
    </script>
</body>
</html>
