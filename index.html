<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>古算体系-哥德巴赫猜想交互验证</title>
    <style>
        /* 样式与之前一致，略 */
    </style>
</head>
<body>
    <div class="container">
        <!-- HTML结构与之前一致，略 -->
    </div>

    <script>
        const SMALL_PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71];
        const SMALL_PRIMES_SET = new Set(SMALL_PRIMES);
        
        // 古算开方术
        function 古算开方(n) {
            if (n < 0) return 0;
            if (n === 0 || n === 1) return n;
            let x = n;
            let y = (x + 1) >> 1;
            while (y < x) {
                x = y;
                y = (x + Math.floor(n / x)) >> 1;
            }
            return x;
        }

        // 古算素数判定（优化版）
        function 古算素数判定(p) {
            if (p <= 1) return false;
            if (SMALL_PRIMES_SET.has(p)) return true;
            if (p % 2 === 0) return false;
            
            // 小素数快速试除
            for (let prime of SMALL_PRIMES) {
                if (prime * prime > p) break;
                if (p % prime === 0) return false;
            }
            
            // 对大数简化验证（工程优化）
            const sqrt_p = 古算开方(p);
            if (sqrt_p > 10000) { // 大数仅验证到10000
                for (let i = 73; i <= 10000; i += 2) {
                    if (p % i === 0) return false;
                }
                return true; // 未发现因子则视为素数（工程妥协）
            }
            
            // 小数完整验证
            for (let i = 73; i <= sqrt_p; i += 2) {
                if (p % i === 0) return false;
            }
            return true;
        }

        // 动态调整素数数量限制
        function sieveOddPrimesUpTo(q) {
            if (q < 3) return [];
            
            if (q <= 10000) {
                const sieve = new Array(q + 1).fill(true);
                sieve[0] = sieve[1] = false;
                for (let i = 3; i * i <= q; i += 2) {
                    if (sieve[i]) {
                        for (let j = i * i; j <= q; j += 2 * i) sieve[j] = false;
                    }
                }
                return sieve.map((isP, idx) => isP && idx % 2 === 1 ? idx : null).filter(idx => idx !== null);
            }
            
            // 按数值大小动态调整素数数量
            const maxPrimes = q < 1000000 ? 200 : q < 10000000 ? 150 : 100;
            const primes = [];
            let num = 3;
            while (primes.length < maxPrimes && num <= q) {
                if (古算素数判定(num)) primes.push(num);
                num += 2;
            }
            return primes;
        }

        // 其他函数（getPrimeFactors、modInverse等）与之前一致，略

        // 扩大素数对查找范围
        function findPrimePairs(n2) {
            const pairs = [];
            const half = Math.floor(n2 / 2);
            
            // 小数暴力验证
            if (n2 < 1000000) {
                for (let p of SMALL_PRIMES) {
                    if (p > half) break;
                    const q = n2 - p;
                    if (古算素数判定(p) && 古算素数判定(q)) {
                        pairs.push([p, q]);
                        if (pairs.length >= 5) return pairs;
                    }
                }
                
                // 扩大遍历范围
                let start = SMALL_PRIMES[SMALL_PRIMES.length - 1] + 2;
                const maxStart = Math.min(half, start + 100000); // 最多遍历10万个
                while (pairs.length < 5 && start <= maxStart) {
                    if (古算素数判定(start)) {
                        const q = n2 - start;
                        if (古算素数判定(q)) {
                            pairs.push([start, q]);
                        }
                    }
                    start += 2;
                }
                return pairs;
            }
            
            // 大数逻辑（略，与之前一致，但扩大候选集）
            const q = 古算开方(n2);
            const MList = sieveOddPrimesUpTo(q);
            const F = getPrimeFactors(n2);
            const MPrime = MList.filter(m => !F.includes(m));
            
            const remainders = [];
            for (let m of MPrime) {
                const r = n2 % m;
                let a = 1;
                while (a === 0 || a === r) a = (a + 1) % m;
                remainders.push(a);
            }
            
            // 扩大候选集数量
            const candidates = generateCandidates(n2, MPrime, remainders, 200); // 生成200个候选
            
            for (let p of candidates) {
                if (p > half) continue;
                const q = n2 - p;
                if (古算素数判定(p) && 古算素数判定(q)) {
                    pairs.push([p, q]);
                    if (pairs.length >= 5) break;
                }
            }
            
            return pairs;
        }

        // 生成候选集时扩大数量
        function generateCandidates(n2, moduli, remainders, maxCandidates = 200) {
            const half = Math.floor(n2 / 2);
            const candidates = [];
            
            for (let p of SMALL_PRIMES) {
                if (p <= half) candidates.push(p);
            }
            
            if (moduli.length > 0) {
                const { a0, M } = solveCongruence(moduli, remainders);
                let t = 0;
                while (candidates.length < maxCandidates) {
                    let candidate = a0 + t * M;
                    if (candidate > half || t > 100) break;
                    if (candidate >= 2 && !candidates.includes(candidate)) {
                        candidates.push(candidate);
                    }
                    t++;
                }
            }
            
            if (candidates.length < maxCandidates) {
                let num = 73;
                while (candidates.length < maxCandidates && num <= half) {
                    if (古算素数判定(num)) candidates.push(num);
                    num += 2;
                }
            }
            
            return [...new Set(candidates)].filter(p => p >= 2 && p <= half);
        }

        // 主验证函数与其他逻辑（略，与之前一致）
        function verifyGoldbach() { /* ... */ }
    </script>
</body>
</html>
